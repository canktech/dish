<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<html> <head>
<title>dish</title>
</head>

<body bgcolor="#ffffff">
<h1>dish --- 分散シェル</h1>
<img src="wheel.gif">
current version: @VERSION@
<ul>
<li><a href="dish_1.20-1_i386.deb">dish_1.20-1_i386.deb</a>
<li><a href="dish-1.20-1_i386.rpm">dish-1.20-1_i386.rpm</a>
<li><a href="dish-@VERSION@.tar.gz">dish-@VERSION@.tar.gz</a>
</ul>
<hr>
dishはGNU makeの内部で使用されている'sh -c'の代わりとして設計されまし
た。dishを使えば、ネットワークで結合された不均質なワークステーションク
ラスタ上で、たくさんの手続きを同時にこなすことができます。
<p>

dishはまるで'sh -c'コマンドのように動作します、つまり、コマンドライン
引数を読み込み、それをBourneシェルスクリプトと解釈して実行します。内部
では、引数は遠隔シェルコマンドrshに渡され、遠隔のワークステーションで
実行され、その結果をステータスとして返します。<p>

アニメーションの製作や多数の音声ファイルの変換、巨大なソフトウェアの翻
訳などのように、数百の独立な処理を分散的に行わなければならない場合に役
に立ちます。<p>

コマンドを実行する遠隔ホストは、与えられたリストの中から選択されます。
もし、システムのアーキテクチャに依存するようなバイナリファイルを作りた
い場合は、リストに含める遠隔ホストは同一のアーキテクチャでなければいけ
ません。<p>

dishは、ローカルディレクトリと同一の遠隔ディレクトリでコマンドを実行し
ます。遠隔ホストとローカルホストがディレクトリを共有し、かつディレクト
リ樹の構造が同一である必要があります。

<h2>コマンドの使い方</h2>
<pre>
usage:  dish [options] foo [x] [bar [y] ... ] -c cmds
dishは、与えられたホスト表のうちから1つを選んでcmdsを実行します。
最大x個のジョブがホストfooに、y個のジョブがホストbarに投入されます。
ジョブの数を省略した場合のデフォルトは1となります。

オプション
    -h, --help         ヘルプを表示します。
    -i, --interactive  標準入力から読みこみます。
                       通常dishは標準入力を無視します。
    -v, --verbose      デバッグメッセージを表示します。
    -r, --refresh      ロックファイルを消去してから実行します。
    -s, --ssh          ershの代わりにsshを使用する。
    -g, --group FILE   ホスト表をファイルから読みこみます。
    -p, --pwd PATH     現在のディレクトリを明示的に指定します。
              通常、dishはPWD環境変数から現在のディレクトリを知りますが、
              PWDシェル変数を設定しないシェルを使用している場合には、
              dishはpwdコマンドを使用して現在のディレクトリの絶対パスを
              入手します。しかし、現在のパスがシンボリックリンクを含む
              場合には、現在の絶対パスの表現の仕方がローカルとリモートで異なる
              ことがあります。
    -c     ホスト名リストの終わりを表わす。
    cmds   実行したいBourne shellコマンド.
</pre>
<h2>Makefileの中の標準シェルを置き換える</h2>
GNU makeは通常一度に1つの規則のみを解釈します。一方、-jオプションを与
えると、並列に実行します。私達は、このGNU makeの並列機能を、ワークステー
ションクラスタ全体でコマンドを実行するのに利用します。-jオプションがあ
ると、GNU makeは規則の依存性を解析し、独立な規則を標準シェルを使って並
列に実行します。それぞれのシェルはMakefile中の規則の短いスレッドを扱い、
終了ステータスコードをGNU makeに返します。<p>

我々は標準シェルをdishでおきかえます。dishは"sh -c"とそっくりにふりま
います。予約変数SHELLがMakefile内で定義された場合、それぞれの規則定義
行は"/bin/sh -c"の代わりにdishで実行されます。dishはそれぞれのスレッド
を遠隔ホストの一つに送り出し、終了ステータスをGNU makeに報告します。<p>

-jオプションで指定される、並列ジョブの最大数は、dishの引数で指定される
xの総和よりもおおきくなくてはいけません。dishは、複数同時に起動された
場合には、自らジョブの個数を制御します。<p>

makeプロセスを複数のホスト上に分散するには、次のようにタイプして下さい。
<pre>
make -j 10 SHELL="dish host1 2 host2 host3 4"
</pre>
makeは10個の独立な規則を同時に実行しようとします。2つはhost1に、1つは
host2に、4つはhost4に送り出され、残り3つは待ち状態になります。<p>

dishはgmakeコマンドを実行しているホスト上で動作します。遠隔ホスト側に
は特に何もインストールする必要はありません。<p>

(v1.21)-gオプションを与えた場合には、ホスト表をコマンドラインから読みこむかわりに、所定のファイル(~/.dish_group/以下に置く)から読みこみます。大規模クラスタでdishを使う場合に便利です。<p>

たとえば、~/.dish_group/clientsに以下のような内容を書いておき、
<pre>
c001 2
c002 2
c003 2
</pre>
次のようなコマンドを実行すると、ホストc001上で2つ、c002上で2つ、c003上で2つの計6つのプロセスを使って"all"をmakeすることができます。
<pre>
make -j 6 all SHELL="dish -g clients"
</pre>

<h2>注意</h2>
標準の遠隔シェルコマンド('rsh')は遠隔で実行した終了ステータスを正しく
返しません。dishでは、Maarten Litmaathによって1994年に書かれたershを代
わりに利用します。-sオプションを与えると、dishはershの代わりにsshを使いますが、この場合
遠隔ホストにsshのサーバが走っている必要があります。
<p>

Linuxでは、makeはGNU makeを意味しますが、一般にはmakeはGNU makeのこと
ではありません。あなたの計算機にGNU makeコマンドがあるかどうか管理者に
相談して下さい。<p>

dishは、排他的プロセス制御のためにホームディレクトリに.dishという名前のワーク
ディレクトリを作成します。<p>

おまけの機能として、dishをonという名前で実行すると、onコマンドの代わり
になります。

<h2>Bugs</h2>
コマンドラインに引用符がたくさんある場合に、dishが上手く動かない場合が
あります。これはdishがシェルスクリプトで書かれていることに起因しており、
うまく回避するためにはc言語でdishを書き直すしかないと思われます。
<h2>メーリングリスト</h2>
<a href="http://citroen.chem.nagoya-u.ac.jp/dish/">dishメーリングリストを開設しました。</a>
<h2>似たもの</h2>
<a href="http://www3.informatik.tu-muenchen.de/~zimmerms/ppmake/">PVM Parallel Make (ppmake)</a>
<h2>更新履歴</h2>
<dl>
<dt>v1.21(平成15年2月19日(水))
<dd>-g|--groupオプションを追加
</dl>
<h2>謝辞</h2>
以下の方々から有用な意見やpatch、貢献などをいただきました。ありがとうございました。(敬称略)
<ul>
<li>山口青星
</ul>
<hr>
コメント、ご意見などは<a
href="mailto:matto@aqua.chem.nagoya-u.ac.jp">matto@aqua.chem.nagoya-u.ac.jp</a>
までお寄せ下さい。<p>
$Id: READMEJ.html,v 1.8 2000/04/14 05:53:26 matto Exp $
<!-- hhmts start -->
Last modified: Mon Feb 28 14:48:49 JST 2000
<!-- hhmts end -->
</body> </html>
