dish watcher(dishを分配するデーモン)の設計---------------------
■とりあえず各個人で立ちあげるものとする。複数のサーバを起動する場合に
は、ポート番号を明示する？先着順で処理するので、forkする必要はない。
■定期的にrpc.rstatdを使ってロードをチェックする。また、ジョブの分配を
行った直後はロードに1を足した数で推定する。(CPU数が多い場合には、load
は1増やすと多すぎる。)xperfmonなどはどうやってる
の？
rupのコードを読む限り、単にRPCの結果を表示しているだけ。ということは、rstatdが平均した結果を返すということか？
システムに準備されているgetloadavg関数でロードを求めているが、こいつは
1分ごとのloadしかわからない。では、xloadは何を表示しているのか？
getloadavgはどうも5秒程度ごとの移動平均を返すらしい。信頼できるloadは、
プロセスが1分以上持続しないと得られない！
topはrunning processesの数を表示している。まさかpsの結果を編集している
ということはないだろうから、processの数を求める関数があるとみた。
平成１１年５月２０日(木)kvm_getprocsでprocess listを得て、RUNのプロセ
スを数えあげればよい。その際、自分自身を差し引くことも可能。RPCでこの
数を返すdaemonを作ろうか？
平成１１年５月２０日(木)benchdを作成。とりあえずTCPsocketで現在の実行
プロセス数を返す。本当はbenchmarkの結果と、CPUの数も知りたい。自分のプ
ロセスの個数はどうやって管理する？benchdはそれほど正確にはプロセス数を
把握しない。

broadcastをとばす？認証できるならそれもいいかも。

けったいなHP-UXはとりあえず相手にしない。LinuxとBSDで動作を確認する。

平成１１年５月２０日(木)benchmark機能を追加した。
■デーモン起動時に、各ワークステーションへのジョブの割り当て量と、各ワー
クステーションのおおよその処理能力を指示しておく。
■dishから問い合わせが来た時には、最も処理が早くすみそうな計算機を教え
てあげる。dishは自分の希望をある程度言うことができる。
■全計算機がある上限のロードに達した時は、回答を遅らせる。これにより、
dishが待ち状態になる。
■負荷の可視化のためのツールと対話するためのプロトコルも定めておく。こ
のツール経由で、設定を動的に変更できるようにする。
■個々のワークステーションに対して管理すべきデータは、
◯CPUを追加することも可能
◯起動しているかどうか・最終問い合わせ時刻
◯CPUあたりの処理能力定数(あとで設定可能)
◯CPU数
◯投入可能ジョブ数(あとで設定可能)
◯現在の投入ジョブ数
◯現在のロードxCPU数(の推定値)

解決すべき問題点
■本物のSMP機の場合、1つのジョブでloadを1にできる。2個目を投入しても1の
まま→推定値が正しくなくなる。(もちろん定期的に修正されるが。)
■投入ジョブ数を管理することはできるが、それが終了したかどうかを知るこ
とができない。(dishのみぞ知る)投入するジョブの個数の管理はdishにやらせ
た方が都合がいいと思う。そうなるとwatcherは単にどのCPUを利用するかを提
案するだけの仕組になるので、問い合わせ通りにCPUが使われているか知るこ
とができない。ということは、特定のCPUに負荷集中する可能性がある。dish
とconnectionを維持するようにしよう。connectionが失なわれた時点で、その
ジョブが終了したものと考える。(となるとサーバはやはりforkしなければい
けない)同じデーモンが一般的な状態問い合わせに答えられるようにするには、
いずれにせよforkしなければいけないだろう。


client		server子プロセス	server親プロセス
通信要求
					CPUがあくまで待つ
					このCPUがあいたよ
					CPU名前を返す
					ジョブカウンタを増やす。
					forkする。
					コネクションの喪失を待つ
コネクション喪失
					ジョブカウンタを1減らす。
					exit

将来の拡張
複数人からの処理の受付
複数のqueueの間の通信


DISH-----------------------------------------------------
dish watcherと連携できるようにする。(そうすれば、dish側は難しいことを
考える必要はまったくなくなる。)

OSの違いの吸収(rshやpwdなど)


ロックファイルをチェックして、どの機械が空いているかを調べる。どれも空いていない場合はしばらく待ってまた確認する。
ロックファイルは、flockなどを使うか、安全のためローカルディスク上に作成する？その必要はないかも。
空いたらすかさずロックをかける。
遠隔計算機の樹がローカルと同じであるかどうかを確かめる。(どこまで保証する？)
遠隔計算機の現行ディレクトリに移動する。
コマンドを実行する。
ロックを解除する。
返り値を正しく返す。rshコマンドはちゃんと値を返さないので、ershスクリ
プトを利用することにした。

pwdコマンドを使うと、厳密な絶対パスが表示されてしまうが、amdを使う場合
にはかえってややこしいことになってしまうので、できれば現在のシェルが理
解しているpath名を使いたい。しかし、そうすると、このスクリプトがシェル
の種類に依存することになる。

キューをちゃんと作って、投入順序を管理した方がよい。
現状だと、LOCKファイルが作られるのが検知できていない？

LOCKファイルは/tmpに生成するようにした。これで、synchronizationの問題
が解消できるはず。

\rを使用して非改行表示をエラー出力に対して行うと、status出力を識別でき
ず、ershが正しい終了コードを返さないようだ。とりあえず、ユーザコマンド
の標準エラー出力の最後に強制的に改行を追加してからershのidを送るように
したけれど、あまりきれいなやりかたとはいえない。できることなら、IDの長
さを固定しておいて、出力の最後の数バイトを切取るようにした方がよい。

C-cを入力した時などに、プロセスが残ってしまうことがあるのはなんとかな
らないか？
